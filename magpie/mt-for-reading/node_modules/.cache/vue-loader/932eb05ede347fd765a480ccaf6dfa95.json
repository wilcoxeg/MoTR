{"remainingRequest":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/magpie-base/src/components/inputs/MazeInput.vue?vue&type=style&index=0&id=dd8a6e9c&scoped=true&lang=css&","dependencies":[{"path":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/magpie-base/src/components/inputs/MazeInput.vue","mtime":1666532369837},{"path":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/css-loader/dist/cjs.js","mtime":1666532361906},{"path":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1666532366719},{"path":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/postcss-loader/src/index.js","mtime":1666532362849},{"path":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/cache-loader/dist/cjs.js","mtime":1666532360087},{"path":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/vue-loader/lib/index.js","mtime":1666532366104}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ci5vcHRpb24gewogIGJhY2tncm91bmQtY29sb3I6ICM1MTg3YmE7CiAgYm9yZGVyOiBub25lOwogIGJvcmRlci1yYWRpdXM6IDJweDsKICBjb2xvcjogd2hpdGU7CiAgY3Vyc29yOiBwb2ludGVyOwogIGRpc3BsYXk6IGlubGluZS1ibG9jazsKICBmb250LWZhbWlseTogJ0xhdG8nLCAnTm90byBTYW5zJywgc2Fucy1zZXJpZjsKICBmb250LXNpemU6IDMwcHg7CiAgbGluZS1oZWlnaHQ6IDQwcHg7CiAgZm9udC13ZWlnaHQ6IDcwMDsKICBsZXR0ZXItc3BhY2luZzogMC45cHg7CiAgbWFyZ2luOiAwIDcwcHggNzBweCA3MHB4OwogIG91dGxpbmU6IG5vbmU7CiAgcGFkZGluZzogNXB4IDEwcHg7CiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsKfQoKLm9wdGlvbjpob3ZlciB7CiAgYmFja2dyb3VuZC1jb2xvcjogIzMyNGQ5MzsKfQo="},{"version":3,"sources":["MazeInput.vue"],"names":[],"mappings":";AAkMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA","file":"MazeInput.vue","sourceRoot":"node_modules/magpie-base/src/components/inputs","sourcesContent":["<docs>\n\n```vue\n<Experiment>\n    <Screen>\n        <MazeInput\n            :targets=\"['This', 'is', 'a', 'nice', 'text']\"\n            :competitors=\"['xxx-xxx', 'can', 'usually', 'quite', 'yummy']\"\n            :response-times.sync=\"$magpie.measurements.times\"\n            :responses.sync=\"$magpie.measurements.responses\"\n            :timeout.sync=\"$magpie.measurements.timeout\"\n            :correct.sync=\"$magpie.measurements.correct\"\n            :target-positions.sync=\"$magpie.measurements.target_positions\"\n            @end=\"$magpie.saveAndNextScreen()\" />\n    </Screen>\n\n    <DebugResultsScreen />\n</Experiment>\n```\n\n</docs>\n\n<template>\n  <div>\n    <SerialInput :iterations=\"targets.length + 1\" @end=\"end\">\n      <template #default=\"{ i, next }\">\n        <template v-if=\"timeout\">\n          <TimerStop\n            id=\"responseTime\"\n            @update:time=\"responseTimes.push($event)\"\n          />\n          <Wait :time=\"0\" @done=\"end\" />\n        </template>\n        <template v-else-if=\"correct\">\n          <TimerStop\n            v-if=\"i > 0\"\n            id=\"responseTime\"\n            @update:time=\"\n              responseTimes.push($event);\n              i === targets.length ? next() : null;\n            \"\n          />\n          <TimerStart id=\"responseTime\" />\n          <Wait\n            v-if=\"responseTimeLimit !== -1\"\n            :time=\"responseTimeLimit\"\n            @done=\"timeout = true\"\n          />\n\n          <KeypressInput\n            :keys=\"{ [leftKey]: 'left', [rightKey]: 'right' }\"\n            :show-options=\"showKeypressOptions\"\n            @update:response=\"\n              correct = targets[i] === getOption($event, i);\n              responses.push(getOption($event, i));\n              next();\n            \"\n          />\n\n          <div class=\"options\">\n            <div class=\"option\">\n              {{ getLeftOption(i) }}\n            </div>\n            <div class=\"option\">\n              {{ getRightOption(i) }}\n            </div>\n          </div>\n        </template>\n        <template v-else>\n          <TimerStop\n            id=\"responseTime\"\n            @update:time=\"responseTimes.push($event)\"\n          />\n          <Wait :time=\"0\" @done=\"end\" />\n        </template>\n      </template>\n    </SerialInput>\n  </div>\n</template>\n\n<script>\nimport KeypressInput from '../inputs/KeypressInput';\nimport SerialInput from '../inputs/SerialInput';\nimport TimerStop from '../helpers/TimerStop';\nimport TimerStart from '../helpers/TimerStart';\nimport _ from 'lodash';\nimport Wait from '../helpers/Wait';\n\nexport default {\n  name: 'MazeInput',\n  components: { Wait, TimerStart, TimerStop, SerialInput, KeypressInput },\n  props: {\n    /**\n     * Target chunks\n     */\n    targets: {\n      type: Array,\n      required: true\n    },\n    /**\n     * Competitor chunks\n     */\n    competitors: {\n      type: Array,\n      required: true\n    },\n    /**\n     * The keyboard key to press for the left continuation\n     */\n    leftKey: {\n      type: String,\n      default: 'f'\n    },\n    /**\n     * The keyboard key to press for the right continuation\n     */\n    rightKey: {\n      type: String,\n      default: 'j'\n    },\n    /**\n     * Whether to show the options for the KeypressInput\n     */\n    showKeypressOptions: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * Maximum time alotted for a single response\n     */\n    responseTimeLimit: {\n      type: Number,\n      default: -1\n    }\n  },\n  data() {\n    const length = this.targets.length;\n    const targetOnLeft = _.map(_.range(length), () => _.random());\n    return {\n      responseTimes: [],\n      responses: [],\n      targetOnLeft,\n      targetPositions: targetOnLeft.map((left) => (left ? 'left' : 'right')),\n      timeout: false,\n      correct: true\n    };\n  },\n  methods: {\n    getLeftOption(i) {\n      return this.targetOnLeft[i] === 1 ? this.targets[i] : this.competitors[i];\n    },\n    getRightOption(i) {\n      return this.targetOnLeft[i] === 0 ? this.targets[i] : this.competitors[i];\n    },\n    getOption(side, i) {\n      return side === 'left' ? this.getLeftOption(i) : this.getRightOption(i);\n    },\n    end() {\n      /**\n       * The list of response times per item\n       * @property {array}\n       */\n      this.$emit('update:response-times', this.responseTimes);\n\n      /**\n       * The list of selected options\n       * @property {array}\n       */\n      this.$emit('update:responses', this.responses);\n      /**\n       * The list of target positions (either 'left' or 'right')\n       * @property {array}\n       */\n      this.$emit('update:target-positions', this.targetPositions);\n      /**\n       * Whether all responses selected the target word\n       * @property {boolean}\n       */\n      this.$emit('update:correct', this.correct);\n      /**\n       * Whether the participant took longer than the timeout for one item and the task was aborted\n       * @property {boolean}\n       */\n      this.$emit('update:timeout', this.timeout);\n      /**\n       * Emitted when the task was aborted due to timeout or incorrect response, or after selecting the last correct option\n       */\n      this.$emit('end');\n    }\n  }\n};\n</script>\n\n<style scoped>\n.option {\n  background-color: #5187ba;\n  border: none;\n  border-radius: 2px;\n  color: white;\n  cursor: pointer;\n  display: inline-block;\n  font-family: 'Lato', 'Noto Sans', sans-serif;\n  font-size: 30px;\n  line-height: 40px;\n  font-weight: 700;\n  letter-spacing: 0.9px;\n  margin: 0 70px 70px 70px;\n  outline: none;\n  padding: 5px 10px;\n  text-transform: uppercase;\n}\n\n.option:hover {\n  background-color: #324d93;\n}\n</style>\n"]}]}