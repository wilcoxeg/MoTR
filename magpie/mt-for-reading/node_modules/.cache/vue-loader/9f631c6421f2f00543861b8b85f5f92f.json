{"remainingRequest":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/magpie-base/src/components/inputs/SelfPacedReadingInput.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/magpie-base/src/components/inputs/SelfPacedReadingInput.vue","mtime":1666532369963},{"path":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/cache-loader/dist/cjs.js","mtime":1666532360087},{"path":"/Users/ethan/Documents/professional/research/mt-methods/mt-for-reading/node_modules/vue-loader/lib/index.js","mtime":1666532366104}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCBLZXlwcmVzc0lucHV0IGZyb20gJy4uL2lucHV0cy9LZXlwcmVzc0lucHV0JzsKaW1wb3J0IFNlcmlhbElucHV0IGZyb20gJy4uL2lucHV0cy9TZXJpYWxJbnB1dCc7CmltcG9ydCBUaW1lclN0b3AgZnJvbSAnLi4vaGVscGVycy9UaW1lclN0b3AnOwppbXBvcnQgVGltZXJTdGFydCBmcm9tICcuLi9oZWxwZXJzL1RpbWVyU3RhcnQnOwppbXBvcnQgV2FpdCBmcm9tICcuLi9oZWxwZXJzL1dhaXQnOwoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdTZWxmUGFjZWRSZWFkaW5nSW5wdXQnLAogIGNvbXBvbmVudHM6IHsgV2FpdCwgVGltZXJTdGFydCwgVGltZXJTdG9wLCBTZXJpYWxJbnB1dCwgS2V5cHJlc3NJbnB1dCB9LAogIHByb3BzOiB7CiAgICAvKioKICAgICAqIFNlbGYtcGFjZWQgcmVhZGluZyB0ZXh0IGNodW5rcwogICAgICovCiAgICBjaHVua3M6IHsKICAgICAgdHlwZTogQXJyYXksCiAgICAgIHJlcXVpcmVkOiB0cnVlCiAgICB9LAogICAgLyoqCiAgICAgKiBHaXZlIGluc3RydWN0aW9ucyBvbiB3aGF0IHRoZSBwYXJ0aWNpcGFudCBpcyBzdXBwb3NlZCB0byBkbwogICAgICovCiAgICBpbnN0cnVjdGlvbnM6IHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICBkZWZhdWx0OiAnUHJlc3MgU1BBQ0UgdG8gcmV2ZWFsIHRoZSB3b3Jkcy4nCiAgICB9LAogICAgLyoqCiAgICAgKiBUaGUga2V5IHRvIHByZXNzIHRvIHJldmVhbCB0aGUgbmV4dCB3b3JkCiAgICAgKi8KICAgIHRyaWdnZXI6IHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICBkZWZhdWx0OiAnICcKICAgIH0sCiAgICAvKioKICAgICAqIFVuZGVybGluZSB0eXBlCiAgICAgKgogICAgICogQHZhbHVlcyB3b3Jkcywgc2VudGVuY2Ugb3Igbm9uZQogICAgICovCiAgICB1bmRlcmxpbmU6IHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICBkZWZhdWx0OiAnbm9uZScKICAgIH0sCiAgICAvKioKICAgICAqIFdoZXRoZXIgdG8gc2hvdyB0aGUgbmV4dCB3b3JkIGF0IHRoZSBzYW1lIHBvc2l0aW9uIG9yIGF0IHRoZSBuZXh0CiAgICAgKgogICAgICogQHZhbHVlcyBzYW1lIG9yIG5leHQKICAgICAqLwogICAgd29yZFBvczogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICdzYW1lJwogICAgfSwKICAgIC8qKgogICAgICogV2hldGhlciB0byBzaG93IHRoZSBvcHRpb25zIGZvciB0aGUgS2V5cHJlc3NJbnB1dAogICAgICovCiAgICBzaG93S2V5cHJlc3NPcHRpb25zOiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IHRydWUKICAgIH0sCiAgICAvKioKICAgICAqIE1heGltdW0gdGltZSBhbG90dGVkIGZvciBhIHNpbmdsZSByZXNwb25zZQogICAgICovCiAgICByZXNwb25zZVRpbWVMaW1pdDogewogICAgICB0eXBlOiBOdW1iZXIsCiAgICAgIGRlZmF1bHQ6IC0xCiAgICB9CiAgfSwKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgcmVzcG9uc2VUaW1lczogW10sCiAgICAgIHRpbWVvdXQ6IGZhbHNlCiAgICB9OwogIH0sCiAgbWV0aG9kczogewogICAgZW5kKCkgewogICAgICAvKioKICAgICAgICogTGlzdCBvZiByZXNwb25zZSB0aW1lcwogICAgICAgKiBAcHJvcGVydHkge2FycmF5fQogICAgICAgKi8KICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnJlc3BvbnNlLXRpbWVzJywgdGhpcy5yZXNwb25zZVRpbWVzKTsKCiAgICAgIC8qKgogICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIHRvb2sgbW9yZSB0aW1lIG9uIG9uZSBpdGVtIHRoYW4gdGhlIHNldCByZXNwb25zZSB0aW1lCiAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9CiAgICAgICAqLwogICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6dGltZW91dCcsIHRoaXMudGltZW91dCk7CgogICAgICAvKioKICAgICAgICogRW1pdHRlZCBlaXRoZXIgd2hlbiB0aGUgdXNlciB0YWtlcyBsb25nZXIgdGhhbiB0aGUgc2V0IHJlc3BvbnNlIHRpbWUsIG9yIHRoZXkgZmluaXNoIHVudGlsIHRoZSBlbmQgb2YgY2h1bmtzLgogICAgICAgKi8KICAgICAgdGhpcy4kZW1pdCgnZW5kJyk7CiAgICB9CiAgfQp9Owo="},{"version":3,"sources":["SelfPacedReadingInput.vue"],"names":[],"mappings":";AA2EA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"SelfPacedReadingInput.vue","sourceRoot":"node_modules/magpie-base/src/components/inputs","sourcesContent":["<docs>\n\n```vue\n<Experiment>\n    <Screen>\n        <SelfPacedReadingInput\n            :chunks=\"['This', 'is', 'a', 'nice', 'and', 'very', 'long', 'text']\"\n            word-pos=\"next\"\n            underline=\"sentence\"\n            trigger=\"$\"\n            instructions=\"Press $ to reveal the next word.\"\n            :response-times.sync=\"$magpie.measurements.times\"\n            @end=\"$magpie.saveAndNextScreen()\" />\n    </Screen>\n\n    <DebugResultsScreen />\n</Experiment>\n```\n\n</docs>\n\n<template>\n  <div>\n    <!-- length + 2, because we have an initial empty slice and a last empty slice to record the rt -->\n    <SerialInput :iterations=\"chunks.length + 2\" @end=\"end\">\n      <template #default=\"{ i, next }\">\n        <template v-if=\"timeout\">\n          <TimerStop\n            id=\"responseTime\"\n            @update:time=\"responseTimes.push($event)\"\n          />\n          <Wait :time=\"0\" @done=\"end\" />\n        </template>\n        <template v-else>\n          <TimerStop\n            v-if=\"i > 1\"\n            id=\"responseTime\"\n            @update:time=\"\n              responseTimes.push($event);\n              i > chunks.length ? next() : null;\n            \"\n          />\n          <TimerStart v-if=\"i > 0\" id=\"responseTime\" />\n          <KeypressInput\n            :keys=\"{ [trigger]: instructions }\"\n            :show-options=\"showKeypressOptions\"\n            @update:response=\"next\"\n          />\n          <Wait\n            v-if=\"responseTimeLimit !== -1 && i > 1\"\n            :time=\"responseTimeLimit\"\n            @done=\"timeout = true\"\n          />\n          <div\n            :class=\"{\n              text: true,\n              'underline-words': underline === 'words',\n              'underline-sentence': underline === 'sentence',\n              'show-all': wordPos === 'next'\n            }\"\n          >\n            <span\n              v-for=\"(chunk, j) in chunks\"\n              :key=\"j\"\n              :class=\"{ current: i - 1 === j }\"\n              v-text=\"chunk\"\n            ></span>\n          </div>\n        </template>\n      </template>\n    </SerialInput>\n  </div>\n</template>\n\n<script>\nimport KeypressInput from '../inputs/KeypressInput';\nimport SerialInput from '../inputs/SerialInput';\nimport TimerStop from '../helpers/TimerStop';\nimport TimerStart from '../helpers/TimerStart';\nimport Wait from '../helpers/Wait';\n\nexport default {\n  name: 'SelfPacedReadingInput',\n  components: { Wait, TimerStart, TimerStop, SerialInput, KeypressInput },\n  props: {\n    /**\n     * Self-paced reading text chunks\n     */\n    chunks: {\n      type: Array,\n      required: true\n    },\n    /**\n     * Give instructions on what the participant is supposed to do\n     */\n    instructions: {\n      type: String,\n      default: 'Press SPACE to reveal the words.'\n    },\n    /**\n     * The key to press to reveal the next word\n     */\n    trigger: {\n      type: String,\n      default: ' '\n    },\n    /**\n     * Underline type\n     *\n     * @values words, sentence or none\n     */\n    underline: {\n      type: String,\n      default: 'none'\n    },\n    /**\n     * Whether to show the next word at the same position or at the next\n     *\n     * @values same or next\n     */\n    wordPos: {\n      type: String,\n      default: 'same'\n    },\n    /**\n     * Whether to show the options for the KeypressInput\n     */\n    showKeypressOptions: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * Maximum time alotted for a single response\n     */\n    responseTimeLimit: {\n      type: Number,\n      default: -1\n    }\n  },\n  data() {\n    return {\n      responseTimes: [],\n      timeout: false\n    };\n  },\n  methods: {\n    end() {\n      /**\n       * List of response times\n       * @property {array}\n       */\n      this.$emit('update:response-times', this.responseTimes);\n\n      /**\n       * Whether the user took more time on one item than the set response time\n       * @property {array}\n       */\n      this.$emit('update:timeout', this.timeout);\n\n      /**\n       * Emitted either when the user takes longer than the set response time, or they finish until the end of chunks.\n       */\n      this.$emit('end');\n    }\n  }\n};\n</script>\n\n<style scoped>\n.text {\n  margin: 30px auto;\n}\n\n.text * {\n  margin-right: 5px;\n}\n\n.text.underline-sentence * {\n  margin-right: 0;\n  padding-right: 5px;\n  border-bottom: 1px solid black;\n}\n\n.text.underline-words * {\n  border-bottom: 1px solid black;\n}\n\n.text :not(.current) {\n  display: none;\n}\n\n.text.show-all :not(.current) {\n  color: transparent;\n  display: inline;\n}\n\n.text .current {\n  color: black;\n  display: inline;\n}\n</style>\n"]}]}